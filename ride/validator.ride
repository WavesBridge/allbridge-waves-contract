{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func toLockKey(lockIdStr: String, key: String) = lockIdStr + key
let keyLockRecipient = "_l.r" # Lock recipient 32-byte
let keyLockAmount = "_l.a" # Lock amount Int
let keyLockDestination = "_l.d" # Lock destination 4-byte
let keyLockTokenSource = "_l.ts"  # Lock token source and address 36-byte

let keyVersion = "_v"   # Binary version number
let keyBridge = "_b"    # Bridge contract address, only bridge can call validator
let keyOracle = "_o"    # 64-byte oracle pubkey
let keyAdmin = "_a"     # Admin address

let errUnauthorized = "unauthorized"
let errUninitialized = "uninitialized"
let errInvalidSignature = "invalid signature"
let errAlreadyClaimed = "claimed"
let errAlreadyLocked = "locked"
let errBridgeOnly = "not bridge"
let errInvalidLockId = "invalid lockId"

func invalidCaller(i: Invocation, key: String) = {
    match getBinary(key) {
        case authority: ByteVector => (authority != i.caller.bytes)
        case _ => false
    }
}

func assertCallerIsBridge(i: Invocation) = {
    if (invalidCaller(i, keyBridge)) 
        then throw(errBridgeOnly)
        else unit
}

func assertValidLockId(lockId: ByteVector) = {
    let version = getBinary(keyVersion).valueOrErrorMessage(errUninitialized)
    if (lockId.size() != 16 || lockId.take(1) != version) 
        then throw(errInvalidLockId)
        else unit
}

func assertLockNotExists(lockRecipientKey: String) = {
    match (getBinary(lockRecipientKey)) {
        case t: ByteVector => throw(errAlreadyLocked)
        case _ => unit
    }
}

@Callable(i)
func setAdmin(newAdmin: ByteVector) = {
    if (invalidCaller(i, keyAdmin)) 
        then throw(errUnauthorized) 
        else [BinaryEntry(keyAdmin, newAdmin)]
}

@Callable(i)
func setConfig(version: ByteVector, bridge: ByteVector, oracle: ByteVector) = {
    if (invalidCaller(i, keyAdmin)) 
        then throw(errUnauthorized) 
        else [
            BinaryEntry(keyVersion, version),
            BinaryEntry(keyBridge, bridge),
            BinaryEntry(keyOracle, oracle)
        ]
}

@Callable(i)
func createUnlock(
    lockId: ByteVector,
    recipient: ByteVector,
    amount: Int,
    lockSource: ByteVector,
    tokenSourceAndAddress: ByteVector,
    signature: ByteVector
) = {    
    strict checkLockId = assertValidLockId(lockId)
    # Check caller, must be bridge contract
    strict checkCaller = assertCallerIsBridge(i)
    # Check if unlock was already created
    let lockIdStr = lockId.toBase64String();
    let lockSourceStr = lockSource.toBase64String();
    let unlockKey = [lockSourceStr, lockIdStr].makeString(".")
    if (isDefined(getBoolean(unlockKey)))
        then throw(errAlreadyClaimed)
        else

    # Construct message
    let message = [
        lockId.toBase64String(),
        recipient.toBase64String(),
        amount.toString(),
        lockSource.toBase64String(),
        tokenSourceAndAddress.toBase64String()
    ].makeString(".")
    
    # Check signature
    let hash = message.toBytes().keccak256()
    
    let recoveredKey = ecrecover(hash, signature)
    if (recoveredKey != getBinaryValue(keyOracle))
        then throw(errInvalidSignature)
        else {
            # Save unlock
            ([BooleanEntry(unlockKey, true)], true)
        }
}


@Callable(i)
func createLock(
    lockId: ByteVector,
    recipient: ByteVector,
    amount: Int,
    lockDestination: ByteVector,
    tokenSourceAndAddress: ByteVector
) = {
    let lockIdStr = lockId.toBase64String()
    let lockRecipientKey = lockIdStr.toLockKey(keyLockRecipient)
    strict checkCaller = assertCallerIsBridge(i)
    strict checkLockId = assertValidLockId(lockId)
    strict checkLock = assertLockNotExists(lockRecipientKey)

    [
        BinaryEntry(lockIdStr.toLockKey(keyLockRecipient), recipient),
        IntegerEntry(lockIdStr.toLockKey(keyLockAmount), amount),
        BinaryEntry(lockIdStr.toLockKey(keyLockDestination), lockDestination),
        BinaryEntry(lockIdStr.toLockKey(keyLockTokenSource), tokenSourceAndAddress)
    ]
}
