{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let keyLockRecipient = "_lr" # Lock recipient 32-byte
let keyLockAmount = "_la" # Lock amount Int
let keyLockDestination = "_ld" # Lock destination 4-byte
let keyLockAssetSource = "_las"  # Lock token source and address 36-byte

let keyVersion = "_v"   # Binary version number
let keyBridge = "_b"    # Bridge contract address, only bridge can call validator
let keyOracle = "_o"    # 64-byte oracle pubkey
let keyAdmin = "_a"     # Admin address
let keyUnlock = "_u"    # Unlock

let errUnauthorized = "unauthorized"
let errUninitialized = "uninitialized"
let errInvalidSignature = "invalid signature"
let errAlreadyClaimed = "claimed"
let errAlreadyLocked = "locked"
let errBridgeOnly = "not bridge"
let errInvalidLockId = "invalid lockId"

func invalidCaller(i: Invocation, key: String) = {
    match getBinary(key) {
        case authority: ByteVector => (authority != i.caller.bytes)
        case _ => false
    }
}

func assertCallerIsBridge(i: Invocation) = {
    if (invalidCaller(i, keyBridge)) 
        then throw(errBridgeOnly)
        else unit
}

func assertValidLockId(lockId: ByteVector) = {
    let version = getBinary(keyVersion).valueOrErrorMessage(errUninitialized)
    if (lockId.size() != 16 || lockId.take(1) != version) 
        then throw(errInvalidLockId)
        else unit
}

func assertLockNotExists(lockRecipientKey: String) = {
    match (getBinary(lockRecipientKey)) {
        case t: ByteVector => throw(errAlreadyLocked)
        case _ => unit
    }
}

@Callable(i)
func setAdmin(newAdmin: ByteVector) = {
    if (invalidCaller(i, keyAdmin)) 
        then throw(errUnauthorized) 
        else [BinaryEntry(keyAdmin, newAdmin)]
}

@Callable(i)
func setConfig(version: ByteVector, bridge: ByteVector, oracle: ByteVector) = {
    if (invalidCaller(i, keyAdmin)) 
        then throw(errUnauthorized) 
        else [
            BinaryEntry(keyVersion, version),
            BinaryEntry(keyBridge, bridge),
            BinaryEntry(keyOracle, oracle)
        ]
}

@Callable(i)
func createUnlock(
    lockId: ByteVector,
    recipient: ByteVector,
    amount: Int,
    lockSource: ByteVector,
    tokenSourceAndAddress: ByteVector,
    signature: ByteVector
) = {    
    strict checkLockId = assertValidLockId(lockId)
    # Check caller, must be bridge contract
    strict checkCaller = assertCallerIsBridge(i)
    # Check if unlock was already created
    let lockIdStr = lockId.toBase64String();
    let lockSourceStr = lockSource.toBase64String();
    let unlockKey = lockSourceStr + "_" + lockIdStr + keyUnlock
    if (isDefined(getBoolean(unlockKey)))
        then throw(errAlreadyClaimed)
        else

    # Construct message
    let message = [
        lockId.toBase64String(),
        recipient.toBase64String(),
        amount.toString(),
        lockSource.toBase64String(),
        tokenSourceAndAddress.toBase64String()
    ].makeString("_")
    
    # Check signature
    let hash = message.toBytes().keccak256()
    
    let recoveredKey = ecrecover(hash, signature)
    if (recoveredKey != getBinaryValue(keyOracle))
        then throw(errInvalidSignature)
        else {
            # Save unlock
            ([BooleanEntry(unlockKey, true)], true)
        }
}


@Callable(i)
func createLock(
    lockId: ByteVector,
    recipient: ByteVector,
    amount: Int,
    lockDestination: ByteVector,
    tokenSourceAndAddress: ByteVector
) = {
    let lockIdStr = lockId.toBase64String()
    let lockRecipientKey = lockIdStr + keyLockRecipient
    strict checkCaller = assertCallerIsBridge(i)
    strict checkLockId = assertValidLockId(lockId)
    strict checkLock = assertLockNotExists(lockRecipientKey)

    [
        BinaryEntry(lockIdStr + keyLockRecipient, recipient),
        IntegerEntry(lockIdStr + keyLockAmount, amount),
        BinaryEntry(lockIdStr + keyLockDestination, lockDestination),
        BinaryEntry(lockIdStr + keyLockAssetSource, tokenSourceAndAddress)
    ]
}
